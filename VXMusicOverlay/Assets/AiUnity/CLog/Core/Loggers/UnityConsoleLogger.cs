#if AIUNITY_CODE

using System;
using AiUnity.CLog.Core.Common;
using System.Text;
using System.Diagnostics;
using System.Reflection;
using UnityEngine.Assertions;
using AiUnity.Common.Extensions;
using System.Text.RegularExpressions;
using AiUnity.Common.InternalLog;
using AiUnity.Common.Log;
using System.Linq;
using System.Collections.Generic;

namespace AiUnity.CLog.Core.Loggers
{
    public class UnityConsoleLogger : SimpleLogger
    {
        #region Properties
        /// <summary>
        /// Holds configuration settings associated with logger instance.
        /// </summary>
        public IUnityConsoleLoggerSettings UnityConsoleLoggerSettings { get; set; }
        #endregion

        #region Constructors
        /// <summary>
        /// Creates and initializes a logger that writes messages to Unity Console.
        /// </summary>
        /// <param name="name">Name associated with the logger</param>
        /// <param name="context">GameObject associated with the logger</param>
        public UnityConsoleLogger(string logName, IUnityConsoleLoggerSettings unityConsoleLoggerSettings, UnityEngine.Object context, IFormatProvider formatProvider) : base(logName, unityConsoleLoggerSettings, context, formatProvider)
        {
            UnityConsoleLoggerSettings = unityConsoleLoggerSettings;
        }
        #endregion

        #region Methods
        /// <summary>
        /// Writes log message to the Unity Console.
        /// </summary>
        /// <param key="levels">The level of this log event.</param>
        /// <param key="message">The message to log</param>
        /// <param key="exception">The exception to log</param>
        protected override void WriteInternal(LogLevels levels, UnityEngine.Object context, object message, Exception exception)
        {
            string formattedMessage = FixUnityConsoleXML(FormatMessage(levels, message, exception));
            UnityEngine.MonoBehaviour monoBehaviour = context as UnityEngine.MonoBehaviour;
            UnityEngine.GameObject unityGameObject = monoBehaviour != null ? monoBehaviour.gameObject : context as UnityEngine.GameObject;

            if (levels.Has(LogLevels.Info) || levels.Has(LogLevels.Debug) || levels.Has(LogLevels.Trace)) {
                UnityEngine.Debug.Log(formattedMessage, unityGameObject);
            }
            else if (levels.Has(LogLevels.Warn)) {
                UnityEngine.Debug.LogWarning(formattedMessage, unityGameObject);
            }
            else {
                UnityEngine.Debug.LogError(formattedMessage, unityGameObject);

                if (levels.Has(LogLevels.Assert) && CLogManager.Instance.AssertException) {
                    throw new AssertException(message.ToString(), exception); ;
                }
            }
        }

        /// <summary>
        /// Formats the message for the Unity Console.
        /// </summary>
        /// <param name="logLevels">The log level.</param>
        /// <param name="message">The message to format.</param>
        /// <param name="exception">The exception to format.</param>
        /// <returns>The formatted message.</returns>
        /// <autogeneratedoc />
        protected string FormatMessage(LogLevels logLevels, object message, Exception exception = null)
        {
            StringBuilder formatedMessage = new StringBuilder();
            string header = CreateMessageInfo(logLevels, 5);

            if (!string.IsNullOrEmpty(header))
            {
                // https://docs.unity3d.com/ScriptReference/ColorUtility.html
                string headerColorCode = UnityEngine.ColorUtility.ToHtmlStringRGBA(UnityConsoleLoggerSettings.HeaderColor);

                if (UnityConsoleLoggerSettings.EnableColors)
                {
                    formatedMessage.AppendFormat("<color=#{0}>{1}</color>", headerColorCode, header);
                }
                else
                {
                    formatedMessage.AppendFormat(header);
                }

                //formatedMessage.Length--;
                if (SimpleLoggerSettings.HeaderNewline)
                {
                    formatedMessage.Append(Environment.NewLine);
                }
                else
                {
                    formatedMessage.Append(":: ");
                }
            }

            string messageColorCode = UnityEngine.ColorUtility.ToHtmlStringRGBA(UnityConsoleLoggerSettings.MessageColor);

            if (UnityConsoleLoggerSettings.EnableColors)
            {
                formatedMessage.AppendFormat("<color=#{0}>{1}</color>{2}", messageColorCode, message, Environment.NewLine);
            }
            else
            {
                formatedMessage.AppendFormat(message + Environment.NewLine);
            }

            if (exception != null) {
                if (UnityConsoleLoggerSettings.EnableColors)
                {
                    formatedMessage.AppendFormat("<color=red>");
                }
                CreateExceptionMessage(formatedMessage, exception);
                if (UnityConsoleLoggerSettings.EnableColors)
                {
                    formatedMessage.AppendFormat("</color>");
                }
            }

            return formatedMessage.ToString();
        }

        /// <summary>
        /// Unity Console literally shows the Rich Text XML if an active tag crosses the second line boundary.
        /// For example if <b> exists on line 2 and </b> on line 3 then all the XML tags themselves will be shown.
        /// This method will close any open tags at the end of line 2 and then reopen those tags on line 3.
        /// </summary>
        /// <param name="message">Message that will have open tags corrected.</param>
        /// <returns>String with no tags crossing the second line boundary.</returns>
        protected string FixUnityConsoleXML(string message)
        {
            Match secondLineEndMatch = Regex.Match(message.TrimEnd('\n'), @"\r?\n").NextMatch();
            int secondLineEndIndex = secondLineEndMatch.Index;

            if (secondLineEndIndex > 0)
            {
                Stack<string> tags = new Stack<string>();

                string messageConsole = message.Substring(0, secondLineEndIndex);
                MatchCollection startTags = Regex.Matches(messageConsole, @"(<\w+[^<>]*>)|(</\w+[^<>]*>)");

                //if (startTags.Count == startTags.Cast<Match>().Count(m => string.IsNullOrEmpty(m.Groups[1].Value))*2)
                foreach (Match match in startTags)
                {
                    if (string.IsNullOrEmpty(match.Groups[1].Value))
                    {
                        // If tags do not match up just return original message
                        if (tags.Count() == 0)
                        {
                            return message;
                        }
                        tags.Pop();
                    }
                    else
                    {
                        tags.Push(match.Groups[1].Value);
                    }
                }

                // Alter message if second line leaves outstanding tags
                if (tags.Count != 0)
                {
                    StringBuilder sb = new StringBuilder(messageConsole);

                    // End outstanding tags
                    foreach (string tag in tags)
                    {
                        Match tagName = Regex.Match(tag, @"<(\w+)[^<>]*>");
                        sb.AppendFormat("</{0}>", tagName.Groups[1].Value);
                    }
                    sb.Append(Environment.NewLine);

                    // Restart outstanding tags
                    sb.Append(string.Join("", tags.Reverse().ToArray()));

                    // Add back third line and above back to the message
                    sb.Append(message.Substring(secondLineEndIndex + secondLineEndMatch.Value.Length));
                    return sb.ToString();
                }
            }
            return message;
        }

        #endregion
    }
}

#endif
